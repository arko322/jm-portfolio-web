<canvas id="hero-constellation" class="absolute inset-0 pointer-events-none"></canvas> <!-- Canvas del efecto constelación -->

<!-- Background effects -->
<div class="absolute inset-0 pointer-events-none"> <!-- Capa de efectos decorativos -->
	<div class="absolute -top-32 left-1/2 -translate-x-1/2 w-5xl h-100 rounded-full
		bg-indigo-500/10 blur-[120px]"></div> <!-- Glow superior -->
	<div class="absolute bottom-0 inset-x-0 h-px bg-white/5"></div> <!-- Línea separadora inferior -->
</div>

<!-- Hero Constellation Script -->
<script>
	(() => {
		const canvas = document.getElementById('hero-constellation') as HTMLCanvasElement; // Canvas
		if (!canvas) return;

		const ctx = canvas.getContext('2d'); // Contexto 2D
		if (!ctx) return;

		// Ajustar tamaño del canvas
		const setCanvasSize = () => {
			canvas.width = window.innerWidth; // Ancho viewport
			canvas.height = window.innerHeight; // Alto viewport
		};
		setCanvasSize();
		window.addEventListener('resize', setCanvasSize); // Recalcular al redimensionar

		// Clase Node
		class Node {
			x: number; // Posición X
			y: number; // Posición Y
			vx: number; // Velocidad X
			vy: number; // Velocidad Y
			radius: number; // Radio
			opacity: number; // Opacidad

			constructor() {
				this.x = Math.random() * canvas.width; // Spawn aleatorio X
				this.y = Math.random() * canvas.height; // Spawn aleatorio Y
				this.vx = (Math.random() - 0.5) * 0.5; // Movimiento lento X
				this.vy = (Math.random() - 0.5) * 0.5; // Movimiento lento Y
				this.radius = Math.random() * 2 + 1; // Tamaño aleatorio
				this.opacity = Math.random() * 0.5 + 0.2; // Opacidad aleatoria
			}

			update() {
				this.x += this.vx; // Avanzar X
				this.y += this.vy; // Avanzar Y

				// Rebotar en bordes
				if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
				if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
			}

			draw() {
				if (!ctx) return;
				ctx.save();
				ctx.globalAlpha = this.opacity; // Aplicar opacidad
				ctx.fillStyle = '#8b5cf6'; // Color de nodos
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); // Dibujar círculo
				ctx.fill();
				ctx.restore();
			}
		}

		// Crear nodos
		const nodeCount = Math.floor((canvas.width * canvas.height) / 15000); // Densidad por tamaño
		const nodes: Node[] = [];
		for (let i = 0; i < nodeCount; i++) {
			nodes.push(new Node()); // Agregar nodo
		}

		// Dibujar conexiones
		function drawConnections() {
			if (!ctx) return;

			const maxDistance = 150; // Distancia máxima de conexión

			for (let i = 0; i < nodes.length; i++) {
				for (let j = i + 1; j < nodes.length; j++) {
					const dx = nodes[i].x - nodes[j].x; // Delta X
					const dy = nodes[i].y - nodes[j].y; // Delta Y
					const distance = Math.sqrt(dx * dx + dy * dy); // Distancia

					if (distance < maxDistance) {
						const opacity = (1 - distance / maxDistance) * 0.3; // Opacidad por distancia

						ctx.save();
						ctx.globalAlpha = opacity; // Aplicar opacidad
						ctx.strokeStyle = '#8b5cf6'; // Color líneas
						ctx.lineWidth = 1; // Grosor línea
						ctx.beginPath();
						ctx.moveTo(nodes[i].x, nodes[i].y); // Inicio
						ctx.lineTo(nodes[j].x, nodes[j].y); // Fin
						ctx.stroke();
						ctx.restore();
					}
				}
			}
		}

		// Loop de animación
		function animate() {
			if (!ctx) return;
			ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar canvas

			// Actualizar y dibujar nodos
			nodes.forEach(node => {
				node.update(); // Actualizar
				node.draw(); // Dibujar
			});

			// Dibujar conexiones
			drawConnections();

			requestAnimationFrame(animate); // Siguiente frame
		}

		animate(); // Iniciar loop

		// Mouse interaction
		let mouseX = -1000; // X fuera de escena
		let mouseY = -1000; // Y fuera de escena

		canvas.addEventListener('mousemove', (e) => {
			mouseX = e.clientX; // Guardar mouse X
			mouseY = e.clientY; // Guardar mouse Y
		});

		canvas.addEventListener('mouseleave', () => {
			mouseX = -1000; // Reset X
			mouseY = -1000; // Reset Y
		});

		// Inyectar influencia del mouse
		const originalUpdate = Node.prototype.update; // Guardar update base
		Node.prototype.update = function() {
			originalUpdate.call(this); // Ejecutar update normal

			// Repulsión cerca del mouse
			if (mouseX > -100) {
				const dx = mouseX - this.x; // Vector X
				const dy = mouseY - this.y; // Vector Y
				const distance = Math.sqrt(dx * dx + dy * dy); // Distancia al mouse

				if (distance < 200) {
					const force = (200 - distance) / 200; // Fuerza por proximidad
					this.x -= (dx / distance) * force * 2; // Empuje X
					this.y -= (dy / distance) * force * 2; // Empuje Y
				}
			}
		};
	})();
</script>